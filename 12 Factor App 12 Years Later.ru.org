#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_EXTRA_CSS: ./css/ember.css
#+REVEAL_EXTRA_CSS: ./css/local.css
#+REVEAL_THEME: none
#+REVEAL_TRANS: fade
#+REVEAL_DEFAULT_FRAG_STYLE: roll-in
#+REVEAL_PLUGINS: (notes highlight)
#+REVEAL_HIGHLIGHT_CSS: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/androidstudio.min.css
#+REVEAL_DEFAULT_FRAG_STYLE: roll-in
#+OPTIONS: toc:nil num:nil reveal_slide_number:nil author:nil date:nil timestamp:nil
#+REVEAL_INIT_OPTIONS: navigationMode:linear
#+REVEAL_HLEVEL: 0
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/local.css" />

#+title: 12 факторов 11 лет спустя

* The Twelve Factors
#+begin_notes
12 факторные приложения это набор практик и принципов для построения приложений как сервисов, готовых к разворачиванию в облаке. Эти принципы были сформулированы в 2011 году Адамом Вингсом, одним из основателей Heroku. В данной презентации предлагаю проследить, как за 11 лет изменились подходы к разработке и автоматизаци.
Для начала перечислим эти принципы:
#+end_notes

#+BEGIN_LARGE_SRC
1. Кодовая база
2. Зависимости
3. Конфигурация
4. Сторонние службы
5. Сборка, релиз, выполнение
6. Процессы
7. Привязка портов
8. Параллелизм
9. Утилизируемость
10. Паритет разработки/работы приложения
11. Журналирование
12. Задачи администрирования
#+END_LARGE_SRC

* История
#+ATTR_HTML: :width 100%
[[./img/heroku-timeline.png]]
#+begin_notes
Heroku это облачная платформа как сервис, запущенная в 2009 году. С момента запуска она долгое время поддерживала только приложения написанные на Ruby, так что можно сказать, что эти принципы выросли из архитектуры фреймворка Ruby On Rails и предназначалась в основном для монолитных приложений, которые и составляли основную массу приложений на Heroku. В то время микросервисы еще не начали набирать популярность, а до релиза docker оставалось 2 года.
#+end_notes


* Кодовая база
Одна кодовая база, отслеживаемая в системе контроля версий

#+begin_notes
Сейчас никого не нужно убеждать в ценности системы контроля версий, но в 2011 это не было таким очевидным. 12 факторов ультимативно заявляют, что каждое приложение должно сущестоввать в отдельном репозитории. Это отчасти связано с философией Heroku, где деплой новой версии запускался командой `git push heroku main` и вся работа  с приложением строилась из расчета отдельного git репозитория. Сейчас же часто предпочитают один монорепозиторий на всю компанию, вместо сотни маленьких. Перечислим плюсы монорепозитоиев.
#+end_notes
#+ATTR_HTML: :width 80%
[[./img/source.excalidraw.png]]

** Монорепозитории
- Проще делать крупномасштабный рефакторинг кода. Все в одном месте, сразу видно, что может сломаться.
- Более гибкое владение кодом. Любой может сделать Pull Request в твой код. Все видят код друг друга
- Проще обеспечить совместимость систем, которые всегда релизятся вместе
- Легче управлять общими зависимостями. Не нужен пакетный менеджер

#+begin_notes
Google, Facebook, Microsoft и Twitter используют огромные монорепозитории. 80 терабайт кода содержится в монорепозитории Google. Между тем, для этого они используют специальные билд тулы, специальные CI/CD пайплайны, свои системы контроля версий.
#+end_notes

* Зависимости
Явно объявляйте и изолируйте зависимости.
Приложение двенадцати факторов никогда не зависит от неявно существующих, доступных всей системе пакетов.

#+ATTR_HTML: :width 30%
[[./img/deps.excalidraw.png]]

#+begin_notes
В идеале сборка вашего приложения должна запускаться одной командой с минимальной предварительной конфигурацией системы. Тоже самое касается и запуска. Новый разработчик, скачав код проекта, не должен тратить пол дня на выполнение многостраничной инструкции, только чтобы собрать приложение. Сами сборки также должны быть повторяемыми, не зависимо от окружения, на котором собираются.
#+end_notes

#+begin_notes
Трудно не согласиться с этим советом, но помимо явного определения всех зависимостей я бы рекомендовал использовать следующие подходы для сборки приложений:
#+end_notes
** Хорошие практики сборки систем
1. Добавьте в ваш репозиторий скрипт для скачивания нужной версии используемой системы сборки
   #+begin_notes
   Скрипт для скачивания и запуска нужной версии билд тула должен быть в репозитории. Не заставляйте разработчика устанавливать необходимые для сборки вашего кода версии тулинга, прежде чем начать работать с кодом. Для java в зависимости используемой системы сборки существуют библиотеки gradle-wrapper и maven-wrapper
   #+end_notes
2. Храните зависимости в приватном репозитории артефактов
   #+begin_notes
   Это позволит контролировать какие именно зависимости используются ваших проектах. Особенно актуально после череды проблем с удалением и подменой репозиториев в том же npm
   #+end_notes
3. Запускайте сборку в docker контейнере
   #+begin_notes
   Это позволяет изолировать системные зависимости для сборки вашего проекта. Это позволяет агентам сборки оставаться настолько простыми, насколько это возможно. Только операционная система и докер. Вся магия сборки происходит внутри контейнеров с jdk, go.
   #+end_notes
4. Инструкция по сборке должна находиться в readme файле проекта

#+begin_notes
В большинстве случаев этого достаточно, чтобы без особых проблем собрать любую версию приложения из исходников.

В особых случаях может потребоваться воспроизводимая или детерминированная сборка. Когда процесс сборки каждый раз выдает одинаковый, с точностью до бита бинарный файл. Что позволяет удостовериться, что результирующий двоичный код в точности соответствует исходному коду. Но для этого потребуется использовать отдельные сложные билд тулы или особые операционные системы.
#+end_notes

* Конфигурация
Сохраняйте конфигурацию приложения в переменных окружения
#+ATTR_HTML: :width 60%
[[./img/configuration.excalidraw.png]]
#+begin_notes
Сейчас всем очевидно, что не стоит хранить в коде параметры, которые зависят от среды запуска приложения. Код должен храниться отдельно от конфигурации. В современных архитектурах иногда выносят управление конфигурациями во внешнюю систему под названием external configuration store.
#+end_notes

** External configuration store
Внешнее хранилище настроек позволяет:
- Менять настройки без перезапуска, преключать фитча флаги
- Совместно использовать настройки несколькими сервисами
- Упростить администрирование настроек множества приложений
- Логировать доступ к настройкам
- Централизовано хранить и управлять секретами

#+ATTR_HTML: :width 60%
[[./img/external-configuration-store.excalidraw.png]]


* Сторонние службы
Считайте сторонние службы подключаемыми ресурсами. Не делайте различий между локальными и сторонними сервисами.

#+ATTR_HTML: :width 50%
[[./img/external-service.excalidraw.png]]
#+begin_notes
Нужно всегда помнить, что сервисы сегодня запущенные на одном сервере завтра могут быть запущены на разных, и подходить к их использованию соответствующим образом. Делая вызов стороннего сервиса всегда помните о следующем:
#+end_notes
- Любой вызов внешнего сервиса может закончиться неудачей
- Внешний сервис может стать недоступным на неопределенное время
- При запросе всегда устанавливайте таймаут на ответ

* Сборка, релиз, выполнение
Разделяйте стадии сборки и выполнения. Одна сборка разворачивается на любые контура с возможностью отката к старому релизу
#+ATTR_HTML: :width 60%
[[./img/build-release-run.excalidraw.png]]

* Процессы
Приложения не должны сохранять свое внутреннее состояние. Это позволит добиться:
- Возможность горизонтального маштабирования
- Перезапуск не приводит к потери информации
#+ATTR_HTML: :width 50%
[[./img/processes.excalidraw.png]]

#+begin_notes
Кеширование и временные хранилища не относится к этому правилу, по определению кэша приложение должно нормально реагировать на потерю данных в нем
#+end_notes

* Привязка портов
Приложение двенадцати факторов является полностью самодостаточным, HTTP сервер встроен в приложение.
#+ATTR_HTML: :width 60%
[[./img/port-binding.excalidraw.png]]
#+begin_notes
Нужно признать, что большие сервера приложений остались в прошлом. Сейчас фреймворки вроде Spring предоставляют разработчикам те же возможности, что и сервера приложений.
#+end_notes
** Минусы серверов приложений
- Требуют установки, что замедляет онбординг разработчика
- Из коробки не работают. Необходимы уникальные знания для поддержки и настройки конкретного сервера
- Поддерживают ограниченный набор технологий. Вы не запустите C# на WebLogic или Tomcat
- Конфигурация расползается между приложением и контейнером


* Параллелизм
Приложение должно уметь горизонтально маштабироваться при необходимости

#+ATTR_HTML: :width 60%
[[./img/concurency.excalidraw.png]]

** Плюсы горизонтального маштабирования
- Ресурсы можно добавлять бесконечно
- Нет остановки сервера при добавлении ресурсов
- Надежнее за счет одновременного запуска приложения на разных машинах
- Случайный запуск двух экземпляров приложения не вызывает проблем

* Утилизируемость
Максимизируйте надёжность с помощью быстрого запуска и корректного завершения работы. Приложения могут быть запущены и остановлены в любой момент.

- При штатном завершении работы закройте все соединения и освободите ресурсы
  #+begin_notes
  Если приложения не закрывать корректно, то это может привести к деградации производительности всей системы.
  Например, если при завершении не вернуть в RabbitMQ очередь необработанное сообщение - это приведет к задержкам в его обработке. Если консьюмер топика в Kafka не пошлет сигнал отключения - он останется висеть в группе до таймаута.
  #+end_notes
- Убедитесь, что приложение корректно обрабатывает сигнал SIGTERM
  #+begin_notes
  Если вы запускаете приложение в kubernetes - то при завершении работы он посылает сигнал SIGTERM в приложение и ждет 60 секунд. Если по прошествии таймаута приложение не закрывается, то посылается сигнал SIGKILL.
  В случае использования spring-boot убедитесь, что в настройках установлен параметр server.shutdown=graceful. Это настройка говорит серверу, что при получении сигнала SIGTERM необходимо остановить прием новых запросов и завершить обработку старых запросов, и только после этого завершить работу. По умолчанию же приложение на spring-boot при получении SIGTERM экстренно завершает работу
  #+end_notes
- Приложение должно быть готово к экстренному завершению в любой момент

** Проблема двойной записи

#+ATTR_HTML: :width 60%
[[./img/disp1.excalidraw.png]]

#+REVEAL: split
#+ATTR_HTML: :width 60%
[[./img/disp2.excalidraw.png]]

#+REVEAL: split
Решение
- Outbox Pattern
- Change Data Capture

#+REVEAL: split
#+ATTR_HTML: :width 60%
[[./img/disp3.excalidraw.png]]

#+REVEAL: split
Решение:
- Идемпотентность API

* Паритет окружений разработки и продуктива
Минимизируйте разрыв между разработкой и работой приложения

- **Различие во времени:** разработчик может работать с кодом, который попадет в рабочую версию приложения только через дни, недели или даже месяцы.
- **Различие персонала:** разработчики пишут код, OPS инженеры разворачивают его.
- **Различие инструментов:** разработчики могут использовать стек технологий, такой как Nginx, SQLite, и OS X, в то время как при рабочем развертывании используются Apache, MySQL и Linux.

** Различие во времени: Trunk Based Development
#+ATTR_HTML: :width 60%
[[./img/trunk.excalidraw.png]]

** Различие персонала: DevOps -> Team Topologies
#+begin_notes
DevOps это одно из многих понятий в IT, оригинальное значение которого уже потеряно во времени. Сейчас этим словом могут называть вообще все что угодно, из за этого оно сильно потеряло в ценности. Некоторые называют DevOps отдел людей, которые сопровождают kubernetes, другие считают, что это когда фронтенд разработчик переустанавливает Linux на агентах сборки его системы.

Не стоит забывать, что поскольку 12 факторов выросли из Paas платформы Heroku, то у них был особый взгляд на DevOps. Действительно, в Heroku разработчик самостоятельно разворачивал и приложение и сервер баз данных, если ему это было необходимо. Вот только делал он это одним кликом мыши на сайте платформы. Никто не шел устанавливать необходимые пакеты и настраивать PostgreSQL, никто не писал Ansible скрипты доставки приложения на контур. И если что-то ломалось - этим занимались инженеры Heroku и чаще всего разработчик даже не замечал, что были какие-то проблемы.

По теме сокращения разрыва между персоналом мне нравится описание команд, приведенных в книге Team Topologies
#+end_notes

- **Stream-aligned team** — команда нацелена на создание и доставку ценности пользователем как можно быстрее. Должна стремиться к максимальной автономности. Цель других типов команд в том, чтобы сократить когнитивную нагрузку на stream-aligned teams.

- **Enabling team** — технические консультанты, помогают stream-aligned teams в повышении их возможностей. Разрабатывают библиотеки, рекламируют новые подходы.

- **Complicated-subsystem team** — отвечают за особую часть системы, которая требует специальных знаний. Например, сопровождение особо сложной математической модели внутри приложения.

- **Platform team** — предоставляют внутренний сервис для снижения когнитивной нагрузки, которая ложится на stream-aligned команды во время работы над их сервисами.

  #+begin_notes
  Если разработчик выполняет роль админа, обязанным разбираться в работе агентов gitlab или в том как обновить кластер kubernetes перескачив через две мажорные версии, то это повышает его когнитивную нагрузку, у него перестает хватать времени на основную его работу - разработку и улучшение продукта. Что в итоге приводит к проблемам и в админ части и в части продукта.
  #+end_notes
** Различие инструментов: Testcontainers
Поднимайте локально в docker необходимые сервисы. Используйте библиотеки типа Testcontainers для интеграционного тестирования

#+begin_src java
@Testcontainers
public class RedisBackedCacheIntTest {

    @Container
    public GenericContainer redis = new GenericContainer(
        DockerImageName.parse("redis:5.0.3-alpine")).withExposedPorts(6379);

    @Test
    void redisIntegrationTest() {
        // ...
    }
}
#+end_src


* Журналирование
Рассматривайте логи как поток событий. Приложение только должно выводить логи в stdout, за сбор и хранение отвечает среда выполнения.

#+ATTR_HTML: :width 100%
[[./img/logs.excalidraw.png]]

#+begin_notes
Хранение, обработка, визуализация, ротация логов это слишком важный и сложный процесс, неразумно его пытаться реализовывать каждый раз с нуля в каждом приложении
#+end_notes

** Используйте структурное логирование
До:
#+begin_src text
2021-07-29 14:54:55.1623|INFO|New report created by user 4253
#+end_src

После:
#+begin_src js
{
    "TimeStamp": "2021-07-29 14:52:55.1623",
    "Level": "Info",
    "Message": "New report created",
    "UserId": 4253,
    "ReportId": 4567,
    "TraceId": "a58fef40-90a3-4c40-a918-e1506e10bc3e"
}
#+end_src

- Позволяет искать логи по конкретным полям
- Нет уникальных паттернов разбора логов для каждого источника
- Добавление сквозного идентификатора процесса позволит связать логи с нескольких систем


* Задачи администрирования
Код и скрипты для администрирования должны поставляться вместе с приложением, чтобы избежать проблем с синхронизацией

- Скрипты миграции схемы БД должны храниться в репозитории приложения
   #+begin_notes
   Если приложение использует БД, то скрипты по созданию всех объектов в этой БД должны храниться вместе с приложением и запускаться самими приложением при старте.
   Это упрощает деплой новых версий, тестирование самих миграций. И исключает ситуации, когда не совпадают версии схемы данных и запущенного приложения
   #+end_notes
- Все разовые скрипты должны запускаться из контекста приложения
   #+begin_notes
   Это позволяет приложению контролировать доступ скрипта к окружению, а так же позволяет скриптам использовать те же настройки, что и приложение. Это уменьшит вероятность, что вы запустите скрипт с неверными настройками.
   #+end_notes

#+ATTR_HTML: :width 60%
[[./img/admin-process.excalidraw.png]]

* Заключение
Следование 12 факторам позволяет добиться:
- Минимизации времени подключения нового разработчика к проекту
- Максимальной переносимость приложения между средами выполнения
- Возможности горизонтального маштабирования
- Использования непрерывного развертывания
- Готовности к разворачиванию в облаке

#+begin_notes
12 факторов были написаны довольно давно, но в общем не утратили своей актуальности сегодня, во времена расцвета микросервисов. Хотя для микросервисов 12 факторов мало, для приемлемой работы. Как минимум стоит к ним добавить темы безопасности и мониторинга
#+end_notes

* Link
- [[https://12factor.net/][The Twelve-Factor App]]
- [[https://architecturenotes.co/12-factor-app-revisited/][12 Factor App Revisited]]
- [[https://www.ibm.com/cloud/blog/7-missing-factors-from-12-factor-applications][7 Missing Factors from 12-Factor Applications]]
- [[https://raw.githubusercontent.com/ffisk/books/master/beyond-the-twelve-factor-app.pdf][Beyond the Twelve-factor app]]
- [[https://apolomodov.medium.com/review-team-topologies-part-1-205533a027c0][Обзор книги “Топологии команд”]]
